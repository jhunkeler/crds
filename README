This directory contains scripts for an HST implementation of CRDS.
Test rmaps were scraped from HTML tables which document them here:

http://www.stsci.edu/hst/observatory/cdbs/

Reference file indices bqy instrument are found in the sidebar topic
"Reference Files".

This software is concerned with the construction of rmaps rather than
their use to generate bestref recommendations.  The semi-automatic
work flow used to construct HST rmaps was as follows:


scrape_indices
--------------

1. For each instrument link in topic "Reference Files", scrape the
data table and store it as XML in <instrument>_index.xml.  This is
done via the script *scrape_indices* and the fairly generic program
*scrape.py* which reduces simple HTML pages to their tables and
outputs XML.  scrape.py also throws away HTML presentation attributes
and puts each table row on a single line.

2. Manually edit <instr>_index.xml as needed to produce a correct
table which maps filekinds onto URLs for tables of reference files.
Step 1 basically outputs the correct table but there are a few
eccentric index rows which have to be hacked manually here.
scrape_indices warns about these for particular instruments and
contains examples of the manual hacks.

gen_imaps
---------

3. Run gen_imaps to process <instr>_index.xml files into imap files.

scrape_files
------------

4. For each filekind row listed in <instr>_index.xml, visit the URLs
for that kind, scrape the selected data tables, and store the results
in <instr>_<filekind>_<number>.xml.  This step is performed by the
script *scrape_files* which runs the program *convert_index.py*. Note
that in these source files, <number> corresponds to a URL, not a file
version as is the case in other areas of CRDS.  convert_index does two
things: (1) it creates <instr>.imap to describe the instrument context
mapping file kinds to rmaps (2) It scrapes the file mapping tables for
each filekind.  Note that the relationship between file kindsand file
mapping data tables is deceptively complex: file_kind --> URL+ -->
file mapping table+.  convert_index will scrape and store one file of
XML for each URL of a filekind.  Each XML file can in turn contain
multiple tables scraped from the same URL.  scrape_files runs the
generic program tselect.py to cherry-pick tables from the NICMOS XML;
tselect un-nests and serializes nested tables, and permits outputting
only specified table numbers.

gen_rmaps
---------

5. After scraping the XML file mapping tables for each filekind in
step 3, the last stage, rmap generation, is performed by the script
*gen_rmaps* which runs the program *rmap.py*.  rmap.py uses the
FILE_KINDS table from cdbs_parkeys to define which table fields to use
as mapping keys for each instrument and filekind.  It is the
FILE_KINDS table, rather than the presence of XML from step 3, which
determines whether or not an rmap will be created and what the primary
lookup key will look like.  As new filekinds are added,
cdbs_parkeys.py must be manually edited to add the kind and its
parkeys.  *rmap.py also defines the header and overall output
structure of the HST rmaps.  Since tables are sometimes used for page
layout rather than data description, rmap.py has a dictionary of
exceptions to the default behavior of using all tables in the file
kind XML.  The manual process of constructing the rmap.py's internal
table is aided by the program *tlist.py* which is used to dump the
column headers of an XML table file; the column headers are then
cherry-picked to choose keys relevant to doing the final lookup.  Note
that the column header keys used here are probably different namings
of FITS header keywords which will ultimately supply the lookup
parameters.

update pipeline
---------------

7. The file hst.pmap is created manually.  Once created, run
crds.checksum on the resulting pmap to rewrite a correct sha1sum.
This step is generally not needed unless support for additional 
instruments is being added,  or additional header items are added.

update naming system
--------------------

6. Once new rmaps have been generated, the program ../tpn.py must be
run in place to regenerate tpn_filekinds.dat and tpn_filetypes.dat.

