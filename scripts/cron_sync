#! /bin/sh 

# usage:  cron_sync
#
#    options:  --check-files --check-sha1sum --fetch-references [context selection]
#
#    example context selections:
#        nothing ==  hst-operational
#        --contexts hst-operational
#        --last 5
#        --all
#
#   requires:  
#        CRDS_PATH        (cache directory)
#        CRDS_SERVER_URL  (server synced from)
#        CRDS_LOCKS       (locks directory)
#
# This script is intended to be run in a cron job at a relatively high
# rate, say once every 30 minutes.  
#
# Several things should be considered for cron rate:
#
#   latency     --  the rate at which cron_sync will notice new files.
# 
#   reliability --  the chance that the unsafe_sync will wind up
#                   transferring reference data while bestrefs is
#                   blocked.
#
#   system load  -- doing both safe and unsafe syncs currently runs
#                   for about a minute,  presumably using primarily
#                   CPU and network,  not memory or disk.   This is
#                   the nominal case where nothing is new or changing.

# Common code and settings between safe and unsafe_sync
. crds_sync_env

( flock --exclusive --nonblock 200 # --nonblock means fail on unavailable locks,  cron collision
  if [[ $? == 1 ]]
  then
    echo "cron_sync: WARNING: failed to obtain crds.sync.lock"
    exit 1
  else
     echo "cron_sync: INFO: obtained crds.sync.lock"
    
     # safe_sync doesn't block bestrefs, syncs rules and references,  doesn't update context / config
     safe_sync $*
    
     # fail here for cron collision
     if [[ $? != 1 ]]
     then
        # unsafe_sync blocks bestrefs, shouldn't sync rules, doesn't sync references, updates context / config.
        unsafe_sync
     fi
  fi
    
) 200> ${CRDS_LOCKS}/crds.sync.lock 
exit 0

#  Summarizing overall design of sync + bestrefs at remote sites:
#
#   crds.sync.lock ensures that no two syncs run concurrently.
#   The nominal safe_sync rate for background reference transfer,
#   i.e. reference pre-positioning, is once every 30 minutes.  If
#   there's nothing new,  not much happens.   If there are new files,
#   safe_sync might run longer than 30 minutes.  So there is latency
#   of 30 minutes,  but indeterminate transfer times which may exceed
#   30 minutes causing the periodic cron_sync to collide with itself.
#   sync.lock manages the collisions causing the 2nd cron_sync to 
#   immediately fail.
#
#   crds.config.lock ensures that unsafe_sync and safe_bestrefs
#   do not concurrently use or modify the cache config area.
#   Additionally,  when running serverless or with a readonly cache,
#   bestrefs will not attempt to update the configuration area.
#
#   As a redundant measure,  to avoid reading half-written files 
#   in bestrefs should locking prove ineffective,  updates to
#   the cache config area are designed to be atomic,  first written
#   to temporary files,  then swapped into final locations with what
#   should be UNIX kernel level atomicity.
#
#   As a fail-safe measure,  presuming a "little concurrency risk"
#   is better than a total fail,  safe_bestrefs only waits on the
#   crds.config.lock for 3 minutes... then proceeds unconcerned.
#   Currently unsafe_sync runs around 30 seconds.

